# 리스트
# 배열이라고 생각하면 됨
# C++의 STL vector, Java의 ArrayList 기능


# 빈 리스트 만들기 a = [] ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# 크기가 n이고, 모든 값이 0인 1차원 리스트 초기화
    # n = 10
    # a = [0] * n
    # print(a) # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

# 리스트의 인덱싱과 슬라이싱 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# 인덱싱
b = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    #idx 0  1  2  3  4  5  6  7  8
    #   -9 -8 -7 -6 -5 -4 -3 -2 -1
        # 원소 변경
            #b[3] = 7

    # 끝 인덱스는 실제 인덱스보다 1을 더 크게 설정한다. (관행적인 것)
        # ex) b[1 : 4] # [2, 3, 4]   .. index 1, 2, 3임.

# 슬라이싱
print(b[1:5]) # 인덱스 1번부터 4번까지 출력 # [5, 4, 3, 2]


# 리스트 컴프리헨션 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# 아주 간단하게 표현 가능(한 줄로)

    # 0부터 9까지의 수를 포함하는 리스트
array = [i for i in range(10)]
print(array) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

c = [i for i in range(20) if i % 2 == 1] # [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
        # i 가 0~19까지 반복하는데, 이 때, 홀수일 때 그 i의 값으로 리스트를 초기화하겠다.
        
        # 이와 같음
        # c = []
        # for i in range(20):
        #     if i % 2 == 1:
        #         c.append(i)

# 2차원 리스트 초기화 할 때 효과적.
# array = [[0] * m for _ in range(n)] 의 형태

    # ex) N x M 크기의 2차원 리스트 초기화
n = 4
m = 3
array2 = [[0] * m for _ in range(n)] # _는 내부적으로 그 변수가 쓰이지 않을 때 씀.
print(array2)
        # 0 0 0
        # 0 0 0
        # 0 0 0 
        # 0 0 0 

# 리스트 관련 기타 메서드 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# 오름차순
    # a.sort()
# 내림차순
    # a.sort(reverse = True)

# 리스트 원소 뒤집기
    # a.revese()
# 특정 인덱스에 데이터 추가
    # a.insert(2, 3)  ..... 인덱스 2에 3 추가
# 특정 값 개수 세기
    # a.count(3)      ..... 데이터 값이 3인 갯수 세기
# 특정 값 삭제
    # a.remove(1)     ..... 값이 1인 데이터 삭제

# sort()와 sorted() 차이
x = [5, 4, 3, 9, 10]
x.sort()
print(x)        # [3, 4, 5, 9, 10]

y = [5, 4, 3, 9, 10]
result = sorted(y)
print(y)        # [5, 4, 3, 9, 10]
print(result)   # [3, 4, 5, 9, 10]
# -> 즉, sort()는 기존 배열을 정렬하지만, sorted()는 기존 배열은 그대로 두고, 복제된 바뀐 값을 따로(result에) 저장해둔다.
# sort() 는 메서드, sorted()는 내장함수

# 리스트에서 특정 값의 원소를 모두 제거하기 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# 파이썬에선 기본적으로 특정 값 하나만 제거 가능함
# 즉, remove_all 같은 건 없음
z = [1, 2, 3, 4, 5, 5, 5]
remove_set = {3, 5}

result1 = [i for i in z if i not in remove_set] # z를 반복하는데, 그 데이터 i가 remove_set에 없다면 출력하라
print(result1) # [1, 2, 4]







