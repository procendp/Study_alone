# 실수형       ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
a = 5.  # 5.0
a = -.7 # -0.7


# 지수표현방식 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
1e9 = 1,000,000,000 # (10의 9제곱)
    # 최단 경로 알고리즘에서는 도달할 수 없는 ㅗㄴ드에 대하여 최단 거리를 무한으로 설정하곤 하는데, 이 때 무한의 값으로 1e9같은 걸 씀.
75.25e1 = 752.5
3954e-3 = 3.954
    # 정수형 데이터로 바꿔 표현하는 게 좋아
         1e9 = 1000000000.0   --> int(1e9) = 1000000000    .. 이런 식으로.

    # 4, 8byte의 고정된 크키에 메모리를 할당하므로, 실수를 표현하는 정확도에 한계가 있음
    # 10진수에선 딱 떨어지지만, 2진수에선 정확한 표현 어려움
    # 0.3 + 0.9 = 0.899999999.. 처럼 표현되곤 함.

    # 이 때를 위해 round() 함수를 이용. <반올림>
         ex) round(123.456, 2) = 123.46


# 자료형 연산  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
    # 나누기 연산자(/)는 나눠진 결과를 [실수]로 반환.
    # 몫 //
    # 나머지 %
    # 거듭 제곱, 제곱근
          ex) a = 5
              b = 3
              # 거듭 제곱
                 print(a ** b) # 125
              # 제곱근
                 print(a ** 0.5) # 2.23606797749979

# 문자열 연산 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# + 이용해서 문자열끼리 이음
# *n 해서 문자열을 n개만큼 표현할 수 있음
# [2:4] 처럼 문자열 슬라이싱도 가능

# 튜플 자료형 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# 튜플은 한 번 할당되고 나면 값을 변경할 수 없음
# []아닌 ()활용
# a = (1, 2, 3, 4)
# a[2] = 7 .... 오류남.     변경x

# 사전 자료형 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# 키와 값의 쌍으로 이루어져 있음
# Key, Value
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana' 
data['코코넛'] = 'Coconut'

print(data)  # {'사과': 'Apple', '바나나': 'Banana', '코코넛': 'Coconut'}

#키나 밸류값만 뽑을 수 있음
# data.keys()        # dict_keys(['사과', '바나나', '코코넛'])
# data.values()      # dict_values(['Apple', 'Banana', 'Coconut'])
# list 형태로 표현 가능
# list(data.keys())     # ['사과', '바나나', '코코넛']
# list(data.values())   # ['Apple', 'Banana', 'Coconut']

# 집합 자료형 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
# 중복 허용x
# 순서 x
# 따라서, 인덱싱으로 값 얻지 못함

# 집합 자료형 초기화 방법 1
# set 사용
dataset1 = set([1, 1, 2, 3, 4, 4, 5])
print(dataset1)     # {1, 2, 3, 4, 5}
# 집합 자료형 초기화 방법 2
# 중괄호{} 사용
dataset2 = {1, 1, 2, 3, 4, 4, 5}
print(dataset2)     # {1, 2, 3, 4, 5}

# 값이 존재하는지, 존재하지 않는지 확인할 때 좋음(시간복잡도 빠름)
c = {1, 2, 3}
# 방법1
c.add(3) # 추가 안됨.(3이 있다는 얘기)
print(c)
# 방법2
print(3 in c) # True .. (3 존재)

# 수식
x = set([1, 2, 3, 4, 5])
y = set([3, 4, 5, 6, 7])
# 합집합
print(x | y) # {1, 2, 3, 4, 5, 6, 7}
# 교집합
print(x & y) # {3, 4, 5}
# 차집합
print(x - y) # {1, 2}


# 원소 추가
q.add(4)
# 원소 여러개 추가
q.update([5, 6])
# 특정 값 삭제
q.remove(3)